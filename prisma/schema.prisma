// This is your Prisma schema file

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id              String          @id @default(cuid())
  name            String
  baseCurrency    String          @default("EUR")
  createdAt       DateTime        @default(now())
  users           User[]
  stores          Store[]
  items           Item[]
  categories      Category[]
  stockEntries    StockEntry[]
  stockCounts     StockCount[]
  roles           Role[]
  suppliers       Supplier[]
  invoices        Invoice[]
  stockMovements  StockMovement[]
  wasteReasons    WasteReason[]
  stockTransfers  StockTransfer[]
  notifications   Notification[]
  // Recipe & Square integration
  recipes                Recipe[]
  squareConnections      SquareConnection[]
  squareCatalogItems     SquareCatalogItem[]
  squareItemMappings     SquareItemMapping[]
  squareModifierMappings SquareModifierMapping[]
  squareOrderSyncs       SquareOrderSync[]
}

model Role {
  id           String   @id @default(cuid())
  name         String
  permissions  String   // JSON string of permissions array
  accountId    String
  account      Account  @relation(fields: [accountId], references: [id])
  isSystemRole Boolean  @default(false)
  users        User[]
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model User {
  id          String       @id @default(cuid())
  email       String       @unique
  name        String?
  image       String?
  accountId   String
  account     Account      @relation(fields: [accountId], references: [id])
  roleId      String?
  role        Role?        @relation(fields: [roleId], references: [id])
  stockCounts StockCount[]
  invoices    Invoice[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
}

model Store {
  id               String            @id @default(cuid())
  name             String
  address          String?
  accountId        String
  account          Account           @relation(fields: [accountId], references: [id])
  stockEntries     StockEntry[]
  stockCounts      StockCount[]
  invoices         Invoice[]
  stockMovements   StockMovement[]
  transfersFrom    StockTransfer[]   @relation("TransferFrom")
  transfersTo      StockTransfer[]   @relation("TransferTo")
  squareConnection SquareConnection? // Each store can have its own Square account
  createdAt        DateTime          @default(now())
}

// Reusable Item Master (like a product catalog)
model Item {
  id                  String              @id @default(cuid())
  name                String
  description         String?
  invoiceItems        InvoiceItem[]
  unit                String              // kg, L, pieces, etc.
  categoryId          String?
  category            Category?           @relation(fields: [categoryId], references: [id])
  supplierId          String?
  supplier            Supplier?           @relation(fields: [supplierId], references: [id])
  accountId           String
  account             Account             @relation(fields: [accountId], references: [id])
  stockEntries        StockEntry[]
  stockMovements      StockMovement[]
  stockTransferItems  StockTransferItem[]
  minStockLevel       Float?              // Optional minimum stock alert level
  maxStockLevel       Float?              // Optional maximum stock level
  sku                 String?             // Optional SKU/product code
  barcode             String?             // Optional barcode
  costPrice           Float?              // Default cost price
  // Recipe relations
  recipeIngredients   RecipeIngredient[]
  squareModifierMappings SquareModifierMapping[]
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
}

// Reusable Categories
model Category {
  id           String        @id @default(cuid())
  name         String
  parentId     String?
  parent       Category?     @relation("CategoryToCategory", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  children     Category[]    @relation("CategoryToCategory")
  invoiceItems InvoiceItem[]
  accountId    String
  account      Account       @relation(fields: [accountId], references: [id])
  items        Item[]
  recipes      Recipe[]
  createdAt    DateTime      @default(now())
}

// Actual Stock Entries (quantity + cost per store)
model StockEntry {
  id               String      @id @default(cuid())
  itemId           String
  item             Item        @relation(fields: [itemId], references: [id])
  storeId          String
  store            Store       @relation(fields: [storeId], references: [id])
  quantity         Float
  unitCost         Float?      // Optional cost
  currency         String      @default("EUR")
  accountId        String
  account          Account     @relation(fields: [accountId], references: [id])
  notes            String?
  stockCountId     String?     // Link to count session if created during a count
  stockCount       StockCount? @relation(fields: [stockCountId], references: [id])
  expectedQuantity Float?      // Calculated expected quantity at time of count
  discrepancy      Float?      // Actual - expected
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt
}

// Stock Count Session - groups multiple stock entries from a single count
model StockCount {
  id               String       @id @default(cuid())
  name             String?      // Optional name like "Weekly Count - Week 3"
  storeId          String
  store            Store        @relation(fields: [storeId], references: [id])
  userId           String       // Who performed the count
  user             User         @relation(fields: [userId], references: [id])
  accountId        String
  account          Account      @relation(fields: [accountId], references: [id])
  status           String       @default("in_progress") // in_progress, completed, approved, cancelled
  entries          StockEntry[]
  totalValue       Float?       // Calculated total value of count
  expectedValue    Float?       // Sum of expected values
  discrepancyValue Float?       // totalValue - expectedValue
  itemsCounted     Int          @default(0)
  notes            String?
  adjustmentNotes  String?      // Notes when approving/adjusting
  completedAt      DateTime?
  approvedAt       DateTime?
  approvedBy       String?      // User ID who approved
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
}

// Supplier/Vendor
model Supplier {
  id        String    @id @default(cuid())
  name      String
  email     String?
  phone     String?
  address   String?
  notes     String?
  accountId String
  account   Account   @relation(fields: [accountId], references: [id])
  invoices  Invoice[]
  items     Item[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@unique([name, accountId]) // Prevent duplicate suppliers with same name per account
}

// Invoice import for tracking purchases
model Invoice {
  id                      String        @id @default(cuid())
  invoiceNumber           String?       // Original invoice number from supplier
  supplierId              String?
  supplier                Supplier?     @relation(fields: [supplierId], references: [id])
  supplierName            String?       // Extracted supplier name (before linking)
  newSupplierDetected     Boolean       @default(false) // Flag to show supplier confirmation dialog
  suggestedSupplierMatchId String?      // ID of similar supplier found during extraction
  storeId                 String
  store                   Store         @relation(fields: [storeId], references: [id])
  userId                  String        // Who uploaded it
  user                    User          @relation(fields: [userId], references: [id])
  accountId               String
  account                 Account       @relation(fields: [accountId], references: [id])
  invoiceDate             DateTime?     // Date on the invoice
  totalAmount             Float?        // Total invoice amount
  currency                String        @default("EUR")
  status                  String        @default("pending") // pending, processing, reviewed, confirmed, error
  fileUrl                 String?       // Stored file URL/path
  fileName                String?
  extractedData           String?       // JSON of AI-extracted data
  items                   InvoiceItem[]
  notes                   String?
  // Mismatch detection - flag when invoice might be uploaded to wrong store
  potentialMismatch       Boolean       @default(false) // True if detected recipient doesn't match store
  detectedRecipient       String?       // Business name detected on invoice (e.g., "Delivered to: Restaurant ABC")
  mismatchReason          String?       // Explanation of why it might be wrong
  mismatchDismissed       Boolean       @default(false) // User dismissed the warning
  createdAt               DateTime      @default(now())
  updatedAt               DateTime      @updatedAt
}

// Individual line items extracted from invoice
model InvoiceItem {
  id                    String   @id @default(cuid())
  invoiceId             String
  invoice               Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  // Extracted fields
  rawName               String   // Original name from invoice
  quantity              Float
  unit                  String?  // Extracted unit (kg, L, pieces, etc.)
  unitPrice             Float?
  totalPrice            Float?
  // Matching to existing items
  matchedItemId         String?  // If matched to existing Item
  matchedItem           Item?    @relation(fields: [matchedItemId], references: [id])
  suggestedName         String?  // AI-suggested clean name for new item
  suggestedUnit         String?  // AI-suggested unit
  categoryId            String?  // Matched/selected category
  category              Category? @relation(fields: [categoryId], references: [id])
  suggestedCategoryName String?  // AI-suggested category name (for creating new category)
  // Status
  status                String   @default("pending") // pending, confirmed, skipped, created
  createdItemId         String?  // If a new item was created from this
  createdAt             DateTime @default(now())
}

// ============================================
// STOCK MOVEMENT TRACKING
// ============================================

enum MovementType {
  PURCHASE     // Stock in from invoice/manual
  WASTE        // Stock out - spoilage/damage
  TRANSFER_IN  // Stock in from another store
  TRANSFER_OUT // Stock out to another store
  ADJUSTMENT   // Count discrepancy adjustment
  SALE         // Future: POS integration
}

// Track all inventory movements (ins and outs)
model StockMovement {
  id            String       @id @default(cuid())
  itemId        String
  item          Item         @relation(fields: [itemId], references: [id])
  storeId       String
  store         Store        @relation(fields: [storeId], references: [id])
  quantity      Float        // Positive for in, negative for out
  type          MovementType
  reason        String?      // For waste: reason code, for adjustment: explanation
  notes         String?
  referenceId   String?      // Invoice ID, Transfer ID, Count ID
  referenceType String?      // "invoice", "transfer", "count", "manual"
  costPrice     Float?       // Cost per unit at time of movement
  createdBy     String?      // User ID who created the movement
  accountId     String
  account       Account      @relation(fields: [accountId], references: [id])
  createdAt     DateTime     @default(now())
}

// Categorized waste reasons
model WasteReason {
  id          String   @id @default(cuid())
  name        String   // "Expired", "Damaged", "Spillage", "Theft", "Other"
  description String?
  isActive    Boolean  @default(true)
  accountId   String
  account     Account  @relation(fields: [accountId], references: [id])
  createdAt   DateTime @default(now())

  @@unique([name, accountId])
}

// ============================================
// INTER-STORE TRANSFERS
// ============================================

enum TransferStatus {
  PENDING
  IN_TRANSIT
  COMPLETED
  CANCELLED
}

// Transfer header - tracks overall transfer between stores
model StockTransfer {
  id            String         @id @default(cuid())
  fromStoreId   String
  fromStore     Store          @relation("TransferFrom", fields: [fromStoreId], references: [id])
  toStoreId     String
  toStore       Store          @relation("TransferTo", fields: [toStoreId], references: [id])
  status        TransferStatus @default(PENDING)
  notes         String?
  createdBy     String?        // User ID who created
  completedBy   String?        // User ID who completed/received
  accountId     String
  account       Account        @relation(fields: [accountId], references: [id])
  items         StockTransferItem[]
  createdAt     DateTime       @default(now())
  completedAt   DateTime?
}

// Individual items in a transfer
model StockTransferItem {
  id          String        @id @default(cuid())
  transferId  String
  transfer    StockTransfer @relation(fields: [transferId], references: [id], onDelete: Cascade)
  itemId      String
  item        Item          @relation(fields: [itemId], references: [id])
  quantity    Float
}

// ============================================
// NOTIFICATIONS / ALERTS
// ============================================

// In-app notifications for alerts
model Notification {
  id        String   @id @default(cuid())
  type      String   // "LOW_STOCK", "DISCREPANCY", "TRANSFER_PENDING", "COUNT_COMPLETED"
  title     String
  message   String
  itemId    String?
  storeId   String?
  linkUrl   String?  // URL to navigate to when clicked
  isRead    Boolean  @default(false)
  userId    String?  // Target user (null = all users in account)
  accountId String
  account   Account  @relation(fields: [accountId], references: [id])
  createdAt DateTime @default(now())
}

// ============================================
// RECIPES & MENU COSTING
// ============================================

// Recipe/Menu Item definition
model Recipe {
  id              String             @id @default(cuid())
  name            String
  description     String?
  imageUrl        String?            // Base64 encoded image or URL
  yieldQuantity   Float              @default(1) // How many portions this recipe makes
  yieldUnit       String             @default("portions") // "portions", "L", "kg", etc.
  categoryId      String?
  category        Category?          @relation(fields: [categoryId], references: [id])
  isSubRecipe     Boolean            @default(false) // True for sauces, prep items that are used in other recipes
  isActive        Boolean            @default(true)
  instructions    String?            // Optional cooking instructions (legacy, kept for backwards compatibility)
  prepTime        Int?               // Prep time in minutes
  cookTime        Int?               // Cook time in minutes
  // Structured instructions with step-by-step photos
  steps           RecipeStep[]
  // Equipment/tools needed
  equipment       String?            // JSON array of equipment names
  // Square item this recipe is linked from (for auto-suggestion)
  squareItemId    String?            // Square catalog item ID this recipe was created from
  accountId       String
  account         Account            @relation(fields: [accountId], references: [id])
  ingredients     RecipeIngredient[]
  // Where this recipe is used as a sub-recipe
  usedIn          RecipeIngredient[] @relation("SubRecipeIngredient")
  // Square integration
  squareItemMappings SquareItemMapping[]
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt
}

// Step-by-step recipe instructions with optional photos
model RecipeStep {
  id          String   @id @default(cuid())
  recipeId    String
  recipe      Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  stepNumber  Int      // Order of the step
  title       String?  // Optional step title like "Prep the vegetables"
  instruction String   // The actual instruction text
  imageUrl    String?  // Optional photo for this step (base64)
  duration    Int?     // Optional duration in minutes for this step
  notes       String?  // Optional tips or notes for this step
  createdAt   DateTime @default(now())

  @@index([recipeId, stepNumber])
}

// Ingredient in a recipe - can be an Item or another Recipe (sub-recipe)
model RecipeIngredient {
  id              String   @id @default(cuid())
  recipeId        String
  recipe          Recipe   @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  // Either an item or a sub-recipe (one must be set)
  itemId          String?
  item            Item?    @relation(fields: [itemId], references: [id])
  subRecipeId     String?
  subRecipe       Recipe?  @relation("SubRecipeIngredient", fields: [subRecipeId], references: [id])
  quantity        Float    // Amount needed per recipe yield
  unit            String   // Unit for this ingredient usage
  notes           String?  // "diced", "julienned", etc.
  wasteFactor     Float    @default(0) // Percentage of waste (0.1 = 10% waste, so need 10% more)
  createdAt       DateTime @default(now())
}

// ============================================
// SQUARE POS INTEGRATION
// ============================================

// Square OAuth connection - one per store (supports different Square accounts per location)
model SquareConnection {
  id                String              @id @default(cuid())
  storeId           String              @unique  // Each store can have its own Square connection
  store             Store               @relation(fields: [storeId], references: [id])
  accountId         String
  account           Account             @relation(fields: [accountId], references: [id])
  name              String?             // Friendly name like "Downtown Square Account"
  merchantId        String              // Square merchant ID
  accessToken       String              // Encrypted access token
  refreshToken      String?             // Encrypted refresh token
  tokenExpiresAt    DateTime?
  squareLocationId  String?             // Specific Square location to sync (if merchant has multiple)
  lastCatalogSync   DateTime?
  lastOrderSync     DateTime?
  syncEnabled       Boolean             @default(true)
  catalogItems      SquareCatalogItem[]
  orderSyncs        SquareOrderSync[]
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
}

// Synced Square catalog items
model SquareCatalogItem {
  id                  String              @id @default(cuid())
  squareId            String              // Square's object ID
  squareConnectionId  String              // Which Square connection this came from
  squareConnection    SquareConnection    @relation(fields: [squareConnectionId], references: [id], onDelete: Cascade)
  accountId           String
  account             Account             @relation(fields: [accountId], references: [id])
  name                String
  description         String?
  categoryName        String?             // Square category
  variations          SquareItemVariation[]
  modifiers           SquareModifier[]
  mappings            SquareItemMapping[]
  isActive            Boolean             @default(true)
  lastSyncedAt        DateTime            @default(now())
  createdAt           DateTime            @default(now())

  @@unique([squareId, squareConnectionId])
}

// Variations of a Square item (e.g., Small, Medium, Large)
model SquareItemVariation {
  id              String            @id @default(cuid())
  squareId        String            // Square's variation object ID
  catalogItemId   String
  catalogItem     SquareCatalogItem @relation(fields: [catalogItemId], references: [id], onDelete: Cascade)
  name            String            // "Small", "Large", etc.
  priceMoney      Float?            // Price in cents
  sku             String?
  mappings        SquareItemMapping[]

  @@unique([squareId, catalogItemId])
}

// Square modifiers (e.g., "Extra Cheese", "No Onions")
model SquareModifier {
  id              String            @id @default(cuid())
  squareId        String            // Square's modifier object ID
  catalogItemId   String
  catalogItem     SquareCatalogItem @relation(fields: [catalogItemId], references: [id], onDelete: Cascade)
  name            String
  priceMoney      Float?            // Additional price
  // Mapping to recipe ingredient additions
  mappings        SquareModifierMapping[]

  @@unique([squareId, catalogItemId])
}

// Map Square item/variation to a Recipe
model SquareItemMapping {
  id              String               @id @default(cuid())
  catalogItemId   String
  catalogItem     SquareCatalogItem    @relation(fields: [catalogItemId], references: [id], onDelete: Cascade)
  variationId     String?              // If mapping specific variation
  variation       SquareItemVariation? @relation(fields: [variationId], references: [id])
  recipeId        String
  recipe          Recipe               @relation(fields: [recipeId], references: [id])
  multiplier      Float                @default(1) // In case quantity differs
  accountId       String
  account         Account              @relation(fields: [accountId], references: [id])
  createdAt       DateTime             @default(now())

  @@unique([catalogItemId, variationId, accountId])
}

// Map Square modifiers to additional ingredients to deduct
model SquareModifierMapping {
  id            String         @id @default(cuid())
  modifierId    String
  modifier      SquareModifier @relation(fields: [modifierId], references: [id], onDelete: Cascade)
  itemId        String         // Item to deduct when this modifier is used
  item          Item           @relation(fields: [itemId], references: [id])
  quantity      Float          // Amount to deduct
  unit          String
  accountId     String
  account       Account        @relation(fields: [accountId], references: [id])
  createdAt     DateTime       @default(now())

  @@unique([modifierId, itemId, accountId])
}

// Track synced Square orders to prevent duplicate processing
model SquareOrderSync {
  id                  String           @id @default(cuid())
  squareOrderId       String
  squareConnectionId  String           // Which Square connection this came from
  squareConnection    SquareConnection @relation(fields: [squareConnectionId], references: [id], onDelete: Cascade)
  accountId           String
  account             Account          @relation(fields: [accountId], references: [id])
  storeId             String           // Which store this order belongs to
  orderDate           DateTime
  totalMoney          Float?
  itemCount           Int
  status              String           @default("synced") // synced, processed, error
  errorMessage        String?
  processedAt         DateTime?
  createdAt           DateTime         @default(now())

  @@unique([squareOrderId, squareConnectionId])
}
